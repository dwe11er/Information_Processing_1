# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sPpYxTQcVoGTRd12z-1XsDAEaWsTCfW1
"""

import pandas as pd
from mlxtend.preprocessing import TransactionEncoder
from mlxtend.frequent_patterns import apriori
import matplotlib.pyplot as plt
from google.colab import files
import csv
from io import StringIO

# 1. Загрузка файла с данными
uploaded = files.upload()
filename = list(uploaded.keys())[0]

# 2. Параметры
min_support = 0.1  # Порог поддержки
sort_method = 'lex'  # Варианты: support или lex
show_plots = True  # Показывать графики

# 3. Функция загрузки данных
def load_data(filename):
    """Загрузка данных из CSV файла с автоматической обработкой кодировок"""
    transactions = []

    # Список кодировок для попытки (в порядке приоритета)
    encodings = ['utf-8', 'windows-1251', 'cp1251', 'latin-1', 'cp866', 'iso-8859-1']

    with open(filename, 'rb') as binary_file:
        raw_data = binary_file.read()

    # Пробуем разные кодировки
    for encoding in encodings:
        try:
            decoded_content = raw_data.decode(encoding)

            # Создаем файлоподобный объект для csv.reader
            file_like = StringIO(decoded_content)

            # Читаем CSV
            reader = csv.reader(file_like)
            for row in reader:
                # Очищаем элементы от пробелов и игнорируем пустые
                cleaned_row = [item.strip() for item in row if item.strip()]
                if cleaned_row:  # Добавляем только непустые строки
                    transactions.append(frozenset(cleaned_row))

            print(f"Файл успешно прочитан в кодировке: {encoding}")
            return transactions

        except (UnicodeDecodeError, csv.Error) as e:
            continue

    # Если ни одна кодировка не подошла
    raise ValueError(
        f"Не удалось прочитать файл '{filename}'. "
        f"Попробованы кодировки: {encodings}. "
    )

# 4. Основной анализ
try:
    print("Загрузка и анализ данных...")

    # Загрузка и подготовка данных
    transactions = load_data(filename)
    if not transactions:
        raise ValueError("Файл пуст или содержит некорректные данные")

    te = TransactionEncoder()
    te_ary = te.fit(transactions).transform(transactions)
    df = pd.DataFrame(te_ary, columns=te.columns_)

    # Выполнение алгоритма Apriori
    frequent_itemsets = apriori(df, min_support=min_support, use_colnames=True)

    if frequent_itemsets.empty:
        print("Не найдено ни одного частого набора с заданным порогом поддержки")
    else:
        # Обработка найденных наборов
        frequent_itemsets['itemsets'] = frequent_itemsets['itemsets'].apply(list)
        frequent_itemsets['length'] = frequent_itemsets['itemsets'].apply(len)

        # Сортировка результатов
        if sort_method == 'support':
            frequent_itemsets = frequent_itemsets.sort_values(
                by=['support', 'length'], ascending=[False, True])
        else:
            frequent_itemsets = frequent_itemsets.sort_values(by='itemsets')

        # 5. Вывод результатов
        print(f"Результаты анализа (порог поддержки: {min_support})")
        print(f"Всего найдено {len(frequent_itemsets)} частых наборов\n")

        # Отображение результатов
        pd.set_option('display.max_rows', None)
        print(frequent_itemsets[['itemsets', 'support']].to_string(index=False))

        # 6. Визуализация результатов
        if show_plots and 'frequent_itemsets' in locals() and not frequent_itemsets.empty:
          print("\nАнализ чувствительности к порогу поддержки")

          supports = [0.01, 0.03, 0.05, 0.1, 0.15]
          results = []

          for s in supports:
              fi = apriori(df, min_support=s, use_colnames=True)
              results.append({
                  'support': s,
                  'total_itemsets': len(fi),
                  'max_length': fi['itemsets'].apply(len).max() if not fi.empty else 0
              })

          results_df = pd.DataFrame(results)

          plt.figure(figsize=(12, 5))

          plt.subplot(1, 2, 1)
          plt.plot(results_df['support'], results_df['total_itemsets'], marker='o')
          plt.title('Количество наборов vs Порог поддержки')
          plt.xlabel('Порог поддержки')
          plt.ylabel('Количество наборов')
          plt.grid(True)

          plt.subplot(1, 2, 2)
          plt.plot(results_df['support'], results_df['max_length'], marker='o', color='orange')
          plt.title('Макс. длина набора vs Порог поддержки')
          plt.xlabel('Порог поддержки')
          plt.ylabel('Максимальная длина')
          plt.grid(True)

          plt.tight_layout()
          plt.show()

except FileNotFoundError:
    print(f"\n❌ Ошибка: файл {filename} не найден")
except Exception as e:
    print(f"\n❌ Произошла ошибка: {str(e)}")